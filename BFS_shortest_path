Finding the shortest path of a graph/Print the shortest path of a graph is a common problem.In this problem we know the number of nodes and number of edges of a graph.We know the edges that connects two nodes.this problem gives us two another more nodes(let A and B).We have to find the shortest path of A to B.For more details...See the following image...
                                    https://images.app.goo.gl/FEikDvfC8jYNDMBAA
for copyright case I don't cpoy and paste the photo here.So check the link please to understand the following writing...
There are 8 nodes and 10 edges.Suppose we have to find the shortest path of node-8 to node-7.To solve the problem we need to know source node,destination node,path,level of node etc....
SOURCE NODE:from which node we start searching.(here node-8)
DESTINATION NODE:from where we stop searching.(here node-7)
PATH:path means route.There can be more than one path between two nodes.here 8 -> 0 -> 1 -> 7 and 8 -> 0 ->3 -> 7 -> 2 are two path.the following picture is a picture of unweighted graph.We consider the weight of each edges are same and that is 1.

First,we need a vector where we can save the graph.
//code:
        #define MAX 1000
        vector<int>graph[MAX];
		
Then we need a boolean array to save and to know a node is visited or not.If a node is visited,then the corrosponding value will be 1 else 0.
//code:
      bool visited[MAX];
	  
Now we need an array that can store the parent node of a node.In that photo if we say our source node is 0 then we can say 0 is the parent of 1,3 and 8.
//code:
       int parent[MAX];
	   
Now we need another more array of integer type that can store the level number of a node.In the photo above 0 is the source node that has no parent.Level of node 0 is 0 and level of node 1,3 and 8 is 1.
//code:
      int level[MAX];
We need a queue data structure to process the BFS algorithm.If you don't know about queue,please search in google.
//code:
      queue<int>q;
Now we have to take input of the graph....
//code:
	int num_nodes , num_edges , x , y ;
	cin >> num_nodes >> num_edges ;
	for(int i = 1 ; i <= num_edges ; i++)
	{
		cin >> x >> y ;//x and y are the node numbers.
		graph[x].push_back(y) ;
		graph[y].push_back(x) ;
	}
Now we have to take input the source node and destination node.
//code:
       int s,d;//s=source ;d=destination;
	   cin>>s>>d;  
Now we have to push the source to the queue q.Then we have to marked the node as visited.We know the parent node of source node is source node.And the level of source node is 0.
//code:
       q.push(s);
	   visited[s]=1;
	   level[s]=0;
	   parent[s]=s;
	   
We have to process the BFS algorithm as long as the queue is not empty.
//code:
      while(!q.empty( ))
	  {
	        code..... ;
	        code..... ;
	  }
Queue works in "First in First out" process.In this part of code,we take the front node,and then pop it from the queue.we have to count the unvisited adjacent node of the front element.
//code:
       int a=q.front( );
	   q.pop( );
	   int size = graph[a].size();

We have to run a loop and find the unused , unvisited adjacent node.
//code:
       for(int i = 0 ; i < size( ) ; i++)
	    {
	       int b=graph[a][i];
		   if(!visited[b])
		   {
		   q.push(b);
		   visited[b] = 1;
		   level[b] = level[a] + 1;
		   parent[b] = a;
		   }
	    }
		
now we have to test our destination node is visited or not.
if not visited;
//code:
      if(!visited[d])
	  {
	       cout << "Not Visited\n" ;
	  }
if it is visited,we have to print the length of shortest path ant the path too.
//code:
else{
       vector<int>path;
	   for( int i = d ; i != s ; i = parent[i] )
	   {
	        path.push_back(i);
	   }
	   cout << path.size( ) << endl;
	   reverse(path.begin( ),path.end( ));
	   cout << s ;
	   vector<int>::iterator itr=path.beginn( );
	   for( ; itr != path.end() ; itr++)
	   { 
	       cout<<" --> " << *itr ;
	   }
	   cout << endl;
	   
    }
								
Program end.....!!!
To get the code visit....https://ideone.com/W1NcoZ
Today I learn BFS.To enhance my knowledge I write that tutorial.
Writer:
       Shahariar Amin.
	   Dept of CSE,RUET.
